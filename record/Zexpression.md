1.	正则表达式<br>
* 计算机可以对代码中的字符串或数据的模式进行匹配、查找或删除<br>
\w :匹配任意一个字母字符或数字字符，包括下划线<br>
\d :匹配任意一个数字<br>
\s :匹配任意一个空格字符    ‘’<br>
+  :匹配一个或多个字符  如：\d+可以匹配2748348<br>
\. :匹配.字符<br>
*  :匹配零个或多个字符或模式 如：\d*可以匹配423425和''<br>
|  :匹配多个模式中的一个（or) 如：\d|\w匹配0或a<br>
[]或():匹配字符类或字符组        [A-C]或(A|B|C)可匹配A<br>
-  :合并字符组<br>
<br>
* 使用内置的正则表达式模块re<br>
<br>
* 	定义一个普通字符串的基本模式：<br>
.findall(模式,字符串)找出这个模式下字符串的所有匹配组成的列表<br>
<br>
.search(,)在整个字符串中搜索匹配，发现匹配对象则返回<br>
<br>
匹配对象.group()返回匹配的字符串<br>
<br>
.match(,)只从字符串的开头开始搜索，原理与search不同：<br>
match(,)方法用于匹配特定模式开头的字符串：若第一个不匹配则返回None<br>
serch(,)方法用于在字符串中找到第一个匹配或任意匹配：直到到达结尾还没找到匹配才返回None<br>
	创建匹配多个模式组的模式：<br>
利用括号的分组功能将多个单词语法放在一起<br>
因为含有多个正则表达式组，若找到匹配则返回多个匹配组<br>
.group()返回的是所有匹配组<br>
 如：Barack Obama<br>
.groups()方法返回所有匹配组构成的列表<br>
 如：('Barack', 'Obama')<br>
<br>
* 使用(?P<命名>正则表达式)为各组命名，候命值需要调用'命名'即可<br>
.finditer(模式，字符串数组)与findall类似,返回的是一个迭代器，利用这个 <br>
要使用for循环调用<br>
在匹配的字符输出的时候用{}占位符表示<br>
如：print('Meet {}!'.format(name.group('first_name')))<br><br>
2.	处理重复记录<br>
  1. 如果数据集只有重复行：清洗数据中删除或舍弃这些行<br>
  2. 如果合并不同的数据集，并希望保存每一条重复数据则：<br>
    使用DictReader模块，方便解析字段<br>
    定义一个函数命名为combine_data_dict,使用def函数：将data_rows合并，然后返回一个字典<br>
    定义一个新的字典，用于函数的返回值<br>
    创建一个唯一键key(用类群编号和家庭编号表示唯一家庭)<br>
    判断：如果已经添加过这个家庭，就把数据加在这个家庭下面<br>
        否则，新建一个列表，添加键/值对<br><br>
3.	总结<br>
字符串格式化（.4f、.2%）------------------可以将数字转换成简单易读的字符串<br>
<br>
datetime 库的strptime 和strftime 方法---------------可以将 Python 日期对象轻松转换成字符串，以及将字符串转换成日期对象<br>
<br>
datetime 库的timedelta 对象---------------表示两个 Python 日期对象之间的时间差，或者用于修改日期对象（例如增加时间或减少时间）<br>
<br>
字符串的format 方法---------------------可以将一系列数据轻松转换成易读的字符串。用 {} 作为数据占位符，传入数据的数量应与其数量相同。还可以用于字典的键名。<br>
<br>
enumerate 方法--------------------传入任意可迭代对象，返回一个由索引编号和对应的值组成的元组<br>
<br>
列表的 index 方法-----------------传入一个元素，返回列表中第一个匹配对象的索引编号。如果没有匹配的话，返回None<br>
<br>
字符串的 find 方法----------------传入一个子字符串，返回它在字符串中的索引位置。如果没有找到匹配，则返回-1<br>
<br>
is 语句--------------------------测试第一个对象和第二个对象是否相同。
<br>
字符串的 isdigit 和isalpha 方法-------------测试字符串对象是否只包含数字或只包含字母。返回一个布尔值
<br>
